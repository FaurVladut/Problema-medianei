# ======== 1. Matricea grafului ========
#un algoritm djikstra pt mediana simpla
# 0 înseamnă că nu există muchie între noduri
graf = [
    [0, 2, 5, 0, 0, 0],
    [2, 0, 1, 2, 0, 0],
    [5, 1, 0, 3, 2, 0],
    [0, 2, 3, 0, 1, 5],
    [0, 0, 2, 1, 0, 2],
    [0, 0, 0, 5, 2, 0]
]

# ======== 2. Algoritmul Dijkstra ========
# (fără cozi, doar liste și bucle)
def dijkstra_simplu(graf, start):
    n = len(graf)
    vizitat = [False] * n           
    dist = [999999] * n            
    dist[start] = 0                 
    for _ in range(n):
        min_dist = 999999
        u = -1
        for i in range(n):
            if not vizitat[i] and dist[i] < min_dist:
                min_dist = dist[i]
                u = i

        if u == -1:
            break

        vizitat[u] = True

        for v in range(n):
            cost = graf[u][v]
            if cost > 0 and not vizitat[v]:
                if dist[u] + cost < dist[v]:
                    dist[v] = dist[u] + cost

    return dist


# ======== 3. Calculăm suma distanțelor pentru fiecare nod ========
n = len(graf)
sume = []
for i in range(n):
    d = dijkstra_simplu(graf, i)
    total = sum(d)
    sume.append(total)
    print(f"Nod {i}: distanțe = {d}, sumă = {total}")

# ======== 4. Afisam nodul median ========
min_sum = min(sume)
nod_median = sume.index(min_sum)

print("\n-----------------------------")
print(f"Nodul median este: {nod_median}")
print(f"Suma minimă a distanțelor: {min_sum}")


# ======== 5.Functia de fitness ========
#genotipul este reprezentat de nod, iar fenotipul este suma distantelor minime 
def fitness(graf, nod):
    dist = dijkstra_simplu(graf, nod)
    cost_total = sum(d for d in dist if d < 999999)
    return 1 / (1 + cost_total)

# ======= 6.Operator de selectie ========
def selectie_turnir(populatie, marime_turnir=3):
    competitori = random.sample(populatie, marime_turnir)
    castigator = min(competitori, key=lambda x: x['fitness'])
    return castigator

# ======= 7.Punct de taiere ========
def incrucisare_un_punct(parinte1, parinte2, total_noduri_graf):
    p = len(parinte1) # Numărul de mediane (p)
    punct_taiere = random.randint(1, p - 1)
    copil_gene = parinte1[:punct_taiere] + parinte2[punct_taiere:]
    copil_gene = list(set(copil_gene))
    while len(copil_gene) < p:
        nod_nou = random.randint(0, total_noduri_graf - 1)
        if nod_nou not in copil_gene:
            copil_gene.append(nod_nou)
    
    return sorted(copil_gene)

# ======= 8.Mutatie =======
def mutatie_vecinatate(cromozom, lista_adiacenta, rata_mutatie=0.1):
    if random.random() > rata_mutatie:
        return cromozom

    p = len(cromozom)
    cromozom_nou = cromozom[:] # Copie
    index_genă = random.randint(0, p - 1)
    nod_curent = cromozom_nou[index_genă]
    vecini = lista_adiacenta.get(nod_curent, [])
    if vecini:
        vecin_nou = random.choice(vecini)
        if vecin_nou not in cromozom_nou:
            cromozom_nou[index_genă] = vecin_nou
            
    return sorted(cromozom_nou)

# ====== 9.Hibridizare =======
def hibridizare_hill_climbing(cromozom, functie_fitness, lista_adiacenta):
    solutie_curenta = cromozom[:]
    fitness_curent = functie_fitness(solutie_curenta)
    imbunatatit = True
    while imbunatatit:
        imbunatatit = False
        
        for i in range(len(solutie_curenta)):
            nod_original = solutie_curenta[i]
            vecini = lista_adiacenta.get(nod_original, [])
            
            for vecin in vecini:
                if vecin in solutie_curenta: continue # Evităm duplicatele
                solutie_test = solutie_curenta[:]
                solutie_test[i] = vecin
                fitness_test = functie_fitness(solutie_test)
                if fitness_test < fitness_curent:
                    solutie_curenta = solutie_test
                    fitness_curent = fitness_test
                    imbunatatit = True
                    break # Ieșim și reluăm bucla mare cu noua soluție
            
            if imbunatatit: break
            
    return solutie_curenta, fitness_curent

# ========10.Supravietuire ==========
def supravietuire_elitism(populatie_veche, populatie_copii, marime_populatie, nr_elita=2):
    populatie_veche.sort(key=lambda x: x['fitness'])
    noua_generatie = [d.copy() for d in populatie_veche[:nr_elita]]
    locuri_ramase = marime_populatie - nr_elita
    noua_generatie.extend(populatie_copii[:locuri_ramase])
    return noua_generatie
