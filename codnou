//1
//in loc de matrice pentru graf avem puncte:
puncte = [
    (2, 3),
    (5, 1),
    (1, 7),
    (6, 4),
    (3, 8),
    (9, 2)
]
//2
//in loc de djikstra avem formula
import math

def distante_euclidiene(punct, puncte):
    x, y = punct
    dist = []
    for (xi, yi) in puncte:
        d = math.sqrt((x - xi)**2 + (y - yi)**2)
        dist.append(d)
    return dist
//3
//calcularea punctului de centru pe baza a 4 puncte predefinite
  puncte_fixe = [(2,3), (5,1), (1,7), (6,4)]  # punctele date
candidate = [(1,1), (2,2), (3,3), (4,4)]    # puncte candidate
  for p in candidate:
    d = distante_euclidiene(p, puncte_fixe)
    total = sum(d)
    sume.append(total)
//4
// afisare
min_sum = min(sume)
index_best = sume.index(min_sum)
punct_median = candidate[index_best]

print("\n-----------------------------")
print(f"Punctul median este: {punct_median}")
print(f"Suma minimă a distanțelor: {min_sum}")
//5
//fitness pentru x,y

def fitness_2d(punct, puncte_fixe):
    """
    punct = (x, y) → candidat din GA
    puncte_fixe = lista de puncte fixe [(xi, yi), ...]
    """
    x, y = punct
    cost_total = 0
    
    for (xi, yi) in puncte_fixe:
        cost_total += math.sqrt((x - xi)**2 + (y - yi)**2)
    
    return 1 / (1 + cost_total)
//6
//selectie turnir sau selectia wheel of fortune(Indivizii cu fitness mare au sansă mai mare sa fie selectati)
def selectie_turnir(populatie, marime_turnir=3):
    competitori = random.sample(populatie, marime_turnir)
    castigator = min(competitori, key=lambda x: x['fitness'])
    return castigator
//7
//crossover
def incrucisare_2d(parinte1, parinte2):
    # parinte1 / parinte2 sunt tupluri: (x, y)
    alpha = random.random()
    x = alpha * parinte1[0] + (1 - alpha) * parinte2[0]
    y = alpha * parinte1[1] + (1 - alpha) * parinte2[1]
    return (x, y)
// alpha e ponderea fiecarui parinte, nu am ales o pondere egala deoarece o pondere de 0.5 poate converge la o solutie neoptima(pondere aleatorie introduce variatie)
//8
//mutatie
def mutatie_2d(cromozom, rata_mutatie=0.1, eps=0.5):
    if random.random() > rata_mutatie:
        return cromozom

    x, y = cromozom
    x += random.uniform(-eps, eps)
    y += random.uniform(-eps, eps)

    return (x, y)
//9
//hibridizare HILL CLIMB:
ef hibridizare_hill_climbing_2d(punct, fitness_func, puncte_fixe, step=0.2):
    x, y = punct
    fitness_curent = fitness_func((x, y), puncte_fixe)
    imbunatatit = True

    while imbunatatit:
        imbunatatit = False
        # 8 direcții + punct fix
        directii = [
            (0, 0),
            (step, 0), (-step, 0),
            (0, step), (0, -step),
            (step, step), (step, -step),
            (-step, step), (-step, -step)
        ]

        for dx, dy in directii:
            x_nou = x + dx
            y_nou = y + dy
            fitness_nou = fitness_func((x_nou, y_nou), puncte_fixe)

            if fitness_nou > fitness_curent:  # mai bun
                x, y = x_nou, y_nou
                fitness_curent = fitness_nou
                imbunatatit = True
                break

    return (x, y), fitness_curent
  //2.HIBRIDIZARE Simulated Annealing:
//dacă e mai bun -> acceptă
//dacă e mai rău -> acceptă cu probabilitate    
//3.Hibridizare cu Random-Restart Hill Climbing — Hill Climb reluat de multe ori

//10
//supravietuire pe baza de elitism: 
          def supravietuire_elitism_2d(populatie_veche, populatie_copii, marime_populatie, nr_elita=2):
    populatie_veche.sort(key=lambda x: x['fitness'], reverse=True)
    
    noua_generatie = [d.copy() for d in populatie_veche[:nr_elita]]
    locuri_ramase = marime_populatie - nr_elita
    
    # deja calculăm fitness la copii
    populatie_copii.sort(key=lambda x: x['fitness'], reverse=True)
    noua_generatie.extend(populatie_copii[:locuri_ramase])
    
    return noua_generatie
